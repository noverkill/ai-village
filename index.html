<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Village Simulation - v0.1 beta</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  canvas {
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body class="flex justify-center items-center">

  <div class="w-full h-full flex flex-col items-center justify-start pt-4">

    <h1 class="text-2xl font-bold">AI Village Simulation - version 0.1 beta</h1>

    <div class="w-full"> <!-- Use flex-grow to fill available space -->
      <canvas id="canvas"></canvas>
    </div>

  </div>

  <script>
  window.onload = function() {

    class AI {
      drive(character, targetX, targetY) {
        let dirX = "None";
        let dirY = "None";
        let chDir = "None";   // the choosen direction we need to calculate
        if (Math.abs(character.x - targetX) > 120) {
          if (character.x > targetX) {
            dirX = "left";
          } else if (character.x < targetX) {
            dirX = "right";
          }
        }
        if (Math.abs(character.y - targetY) > 120) {
          if (character.y < targetY) {
            dirY = "down";
          } else if (character.y > targetY) {
            dirY = "up";
          }
        }
        if(dirX == "None" && dirY == "None") {
          character.stop();
        } else {
          if(dirY == "None" && dirX !== "None") chDir = dirX;
          else if(dirX == "None" && dirY !== "None") chDir = dirY;
          else chDir = Math.random() < 0.5 ? dirX : dirY;
          character.move(chDir);
        }
      };
    }

    class TextBubble {
      constructor(
        ctx,
        maxWidth = 150,
        maxHeight = 100,
        minFontSize = 12,
        maxFontSize = 24,
        characterSize = 64,
        maxCharactersPerLine = 20,
        padding = 5
      ) {
        this.ctx = ctx;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.maxCharactersPerLine = maxCharactersPerLine;
        this.minFontSize = minFontSize;
        this.maxFontSize = maxFontSize;
        this.characterSize = characterSize;
        this.padding = padding;
      };
      show(text, x, y) {
          const ctx = this.ctx;
          const padding = this.padding;
          const bubbleWidth = Math.max(this.characterSize, Math.min(this.maxWidth, text.length * (this.maxFontSize / 2))) + (padding * 4);
          let fontSize = this.maxFontSize;
          do {
              ctx.font = fontSize + 'px Arial';
              var metrics = ctx.measureText(text);
              // var fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
              var actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
              var lineHeight = actualHeight;
              var newTextWidth = metrics.width;

              if (newTextWidth > bubbleWidth - padding * 2 || lineHeight * Math.ceil(text.length / this.maxCharactersPerLine) > this.maxHeight - padding * 2) {
                  fontSize -= 1;
              }
          } while (fontSize >= this.minFontSize && (ctx.measureText(text).width > bubbleWidth - padding * 2 || lineHeight > this.maxHeight - padding * 2));
          const lines = [];
          let line = '';
          for (let i = 0; i < text.length; i++) {
              line += text[i];
              if (line.length === this.maxCharactersPerLine || i === text.length - 1) {
                  lines.push(line);
                  line = '';
              }
          }
          const bubbleHeight = Math.min(this.maxHeight, lines.length * lineHeight) + (padding * 2);
          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          let offsetX = 10;
          let offsetY = 40;
          const lineWidth = 2;
          ctx.beginPath();
          ctx.rect(x - offsetX, y + offsetY, bubbleWidth, bubbleHeight);
          ctx.closePath();
          ctx.lineWidth = lineWidth;
          ctx.stroke();
          ctx.fill();
          // triangle for the speech bubble
          ctx.beginPath();
          ctx.moveTo(x + bubbleWidth / 2, y + offsetY + bubbleHeight + 15);
          ctx.lineTo(x + bubbleWidth / 2 - 10, y + offsetY + bubbleHeight + lineWidth);
          ctx.lineTo(x + bubbleWidth / 2 + 10, y + offsetY + bubbleHeight + lineWidth);
          ctx.closePath();
          ctx.fillStyle = 'black';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = lineWidth;
          ctx.stroke();
          ctx.fill();
          ctx.fillStyle = 'black';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          lines.forEach(line => {
              ctx.fillText(line, x - offsetX + bubbleWidth / 2, y + offsetY + lineHeight / 2 + padding);
              offsetY += lineHeight;
          });
      };
    }

    var ai = new AI();

    class Village {
      constructor(ctx) {
        this.ctx = ctx;
        this.margin = 5;
        this.objects = [];
        this.counter = 0;
      };
      addObject(object) {
        this.objects.push(object);
      };
      draw () {
        this.ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.addBorder();
        this.counter = (this.counter + 1) % 5;
        if(this.counter == 0) {
          ai.drive(this.objects[1], this.objects[0].x, this.objects[0].y);
        }
        this.objects.forEach(function(object) {
          object.draw();
        });
      };
      addBorder(lineWidth = 2) {
        const ctx = this.ctx;
        const margin = this.margin;
        // Define the start and end points of the rectangle's edges
        const startX = margin;
        const startY = margin;
        const endX = ctx.canvas.width - margin;
        const endY = ctx.canvas.height - margin;
        ctx.lineWidth = lineWidth;
        // Begin a new path for the border lines
        ctx.beginPath();
        // Top line
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, startY);
        // Right line
        ctx.lineTo(endX, endY);
        // Bottom line
        ctx.lineTo(startX, endY);
        // Left line
        ctx.lineTo(startX, startY);
        // Draw the lines
        ctx.stroke();
      };
    };

    class Character {
      constructor(
        village,
        imageSrc,
        width,
        height,
        x,
        y,
        speed,
        direction,
        message = "Uh oh!",
        isMoving = false
      ) {
        this.village = village;
        this.image = new Image();
        this.image.src = imageSrc;
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.direction = direction;
        this.message = message;
        this.isMoving = isMoving;

        this.previousDirection = direction;
        this.ctx = this.village.ctx;
        this.directions = {"left": 2, "right": 3, "up": 1, "down": 0};
        this.currentFrame = 0;
        this.village.addObject(this);
        this.notMovedSteps = 0;
        this.textBubble = new TextBubble(this.ctx);
      }

      setMessage (message = "Move!") {
        this.message = message;
      };

      getMessage() {
        return this.message;
      };

      move(direction) {
        // turn character first in
        // case of change of direction
        if (this.direction !== direction) {
          this.currentFrame = 0;
          this.prevdirection = direction;
          this.direction = direction;
          // this.village.draw();
        }
        switch (direction) {
          case "left": this.x -= this.speed; break;
          case "right": this.x += this.speed; break;
          case "up": this.y -= this.speed; break;
          case "down": this.y += this.speed; break;
        }
        this.isMoving = true;
        this.notMovedSteps = 0;
        this.currentFrame = (this.currentFrame + 1) % 4; // Assuming 4 frames per direction
        // this.village.draw();
      };

      stop() {
        this.isMoving = false;
      };

      draw() {
        this.ctx.drawImage(this.image, this.currentFrame * this.width, this.directions[this.direction] * 100, this.width, this.height, this.x, this.y, this.width, this.height);
        if (!this.isMoving) {
          this.notMovedSteps += 1;
          if (this.notMovedSteps > 15) {
            this.textBubble.show(this.getMessage(), this.x - 15, this.y - 65);
          }
        }
      };
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = canvas.parentElement; // Assuming the canvas is directly inside the container
    canvas.height = container.clientHeight - 50;
    canvas.width = container.clientWidth;

    // Delay in milliseconds before showing the message when character stop moving
    const messageDelay = 2000;

    var village = new Village (ctx);

    var character1 = new Character (
      /*village*/ village,
      /*sprite*/ 'character_sprite_sheet-small.png',
      /*width*/ 64,
      /*height*/ 84,
      /*pos x*/ 100,
      /*posy*/ 100,
      /*speed*/ 8,
      /*direction*/ "right",
      /*message*/ "Uh Oh!",
      /*isMoving*/ true
    );

    var character2 = new Character (
      /*village*/ village,
      /*sprite*/ 'character_sprite_sheet-small.png',
      /*width*/ 64,
      /*height*/ 84,
      /*pos x*/ 700,
      /*posy*/ 500,
      /*speed*/ 8,
      /*direction*/ "left",
      /*message*/ "Fuuckk!"
    );

    // Handle keyboard input for movement
    document.addEventListener('keydown', function(event) {
        event.preventDefault();
        switch(event.key) {
          case 'ArrowLeft':
            character1.move("left");
            break;
          case 'ArrowRight':
            character1.move("right");
            break;
          case 'ArrowUp':
            character1.move("up");
            break;
          case 'ArrowDown':
            character1.move("down");
            break;
        }
    });

    // Reset the movement flag when the character stops moving
    document.addEventListener('keyup', function(event) {
        event.preventDefault();
        switch(event.key) {
          case 'ArrowLeft':
          case 'ArrowRight':
          case 'ArrowUp':
          case 'ArrowDown':
            character1.stop();
        }
    });

    // village.draw();
    const intervalId = setInterval(village.draw.bind(village), 25);

  };
  </script>

</body>
</html>
