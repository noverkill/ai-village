<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Village Simulation - v0.1 beta</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  canvas {
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body class="flex justify-center items-center">

  <div class="w-full h-full flex flex-col items-center justify-start pt-4">

    <h1 class="text-2xl font-bold">AI Village Simulation - version 0.1 beta</h1>

    <div class="w-full"> <!-- Use flex-grow to fill available space -->
      <canvas id="canvas"></canvas>
    </div>

  </div>

  <script>
  window.onload = function() {

    const canvas = document.getElementById('canvas');
    const container = canvas.parentElement; // Assuming the canvas is directly inside the container

    canvas.height = container.clientHeight - 50;
    canvas.width = container.clientWidth;

    const ctx = canvas.getContext('2d');

    const characterWidth = 64; // Width of each character frame in the sprite sheet
    const characterHeight = 84; // Height of each character frame in the sprite sheet

    const characterSpeed = 8; // Movement speed

    let characterX = 100; // Initial X position
    let characterY = 100; // Initial Y position

    // Load character sprite sheet
    const characterImage = new Image();
    characterImage.src = 'character_sprite_sheet-small.png';

    // Current frame index on character sprite sheet
    let currentFrame = 0;

    const directions = {"left": 2, "right": 3, "up": 1, "down": 0};
    let direction = "left";
    let prevDirection = "left";

    const messageDelay = 2000; // Delay in milliseconds before showing the message when character stop moving
    let isMoving = false; // Flag to track character movement state
    let showMessage = false; // Flag to indicate whether to show the message

    function getMessage() {
      //return "Move motherfucker or die! We don't have time to fuck around here!";
      return "Uh oh!";
    }

    // Update frame index for animation
    function updateFrame() {
      currentFrame = (currentFrame + 1) % 4; // Assuming 4 frames in the sprite sheet for simplicity
    }

    // Update direction for animation
    function updateDirection(dir) {
      if (direction !== dir) {
        currentFrame = 0;
        prevdirection = direction;
        direction = dir;
        drawCharacter();
      }
    }

    // Draw character sprite
    function drawCharacter() {
      // console.log("direction", directions[direction]);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      addBorder(ctx, 5);

      ctx.drawImage(characterImage, currentFrame * characterWidth, directions[direction] * 100, characterWidth, characterHeight, characterX, characterY, characterWidth, characterHeight);

      // // console.log(characterImage, currentFrame * characterWidth, 0, characterWidth, characterHeight, characterX, characterY, characterWidth, characterHeight);

      // console.log("drawCharacter isMoving", isMoving);

      if (!isMoving && showMessage) {
        drawTextInBubble(getMessage(), characterX - 15, characterY - 65);
        showMessage = false;
      }
    }

    function addBorder(ctx, margin) {
      const lineWidth = 2; // Line width of 2px
      ctx.lineWidth = lineWidth;

      // Define the start and end points of the rectangle's edges
      const startX = margin;
      const startY = margin;
      const endX = ctx.canvas.width - margin;
      const endY = ctx.canvas.height - margin;

      // Clear previous drawings
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // Begin a new path for the border lines
      ctx.beginPath();

      // Top line
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, startY);

      // Right line
      ctx.lineTo(endX, endY);

      // Bottom line
      ctx.lineTo(startX, endY);

      // Left line
      ctx.lineTo(startX, startY);

      // Draw the lines
      ctx.stroke();
    }

    /*
     / Params:
     / characterSize: Assuming character size is 64px * 64px
    */
    function drawTextInBubble(text, x, y, characterSize = 64, maxBubbleWidth = 150, maxBubbleHeight = 100, maxCharactersPerLine = 20, minFontSize = 12, maxFontSize = 24) {
        const padding = 5;

        const bubbleWidth = Math.max(characterSize, Math.min(maxBubbleWidth, text.length * (maxFontSize / 2))) + (padding * 4);

        let fontSize = maxFontSize;

        do {
            ctx.font = fontSize + 'px Arial';
            var metrics = ctx.measureText(text);
            // var fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
            var actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
            var lineHeight = actualHeight;
            var newTextWidth = metrics.width;

            if (newTextWidth > bubbleWidth - padding * 2 || lineHeight * Math.ceil(text.length / maxCharactersPerLine) > maxBubbleHeight - padding * 2) {
                fontSize -= 1;
            }
        } while (fontSize >= minFontSize && (ctx.measureText(text).width > bubbleWidth - padding * 2 || lineHeight > maxBubbleHeight - padding * 2));

        const lines = [];
        let line = '';
        for (let i = 0; i < text.length; i++) {
            line += text[i];
            if (line.length === maxCharactersPerLine || i === text.length - 1) {
                lines.push(line);
                line = '';
            }
        }

        const bubbleHeight = Math.min(maxBubbleHeight, lines.length * lineHeight) + (padding * 2);

        // console.log("lines.length * lineHeight", lines.length * lineHeight);
        // console.log("Math.min", Math.min(maxBubbleHeight, lines.length * lineHeight));
        // console.log("Math.max", Math.max(characterSize, Math.min(maxBubbleHeight, lines.length * lineHeight)));
        // console.log("bubbleHeight", bubbleHeight);

        // console.log("ctx.font", ctx.font);
        // console.log("fontSize", fontSize);
        // console.log("font actual height", actualHeight);

        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;

        // console.log(text, x, y);
        // console.log(bubbleWidth);
        // console.log(lineHeight);
        // console.log(bubbleHeight);

        let offsetX = 10;
        let offsetY = 40;

        const lineWidth = 2;

        ctx.beginPath();
        ctx.rect(x - offsetX, y + offsetY, bubbleWidth, bubbleHeight);
        ctx.closePath();
        ctx.lineWidth = lineWidth;
        ctx.stroke();
        ctx.fill();

        // Draw triangle for the speech bubble
        ctx.beginPath();
        ctx.moveTo(x + bubbleWidth / 2, y + offsetY + bubbleHeight + 15);
        ctx.lineTo(x + bubbleWidth / 2 - 10, y + offsetY + bubbleHeight + lineWidth);
        ctx.lineTo(x + bubbleWidth / 2 + 10, y + offsetY + bubbleHeight + lineWidth);
        ctx.closePath();
        ctx.fillStyle = 'black';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = lineWidth;
        ctx.stroke();
        ctx.fill();

        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        lines.forEach(line => {
            ctx.fillText(line, x - offsetX + bubbleWidth / 2, y + offsetY + lineHeight / 2 + padding);
            offsetY += lineHeight;
        });
    }

    // Handle keyboard input for movement
    document.addEventListener('keydown', function(event) {
        event.preventDefault();
        switch(event.key) {
          case 'ArrowLeft':
            updateDirection("left");
            characterX -= characterSpeed;
            updateFrame();
            isMoving = true;
            showMessage = false; // Reset showMessage flag when character starts moving
            drawCharacter();
            break;
          case 'ArrowRight':
            updateDirection("right");
            characterX += characterSpeed;
            updateFrame();
            isMoving = true;
            showMessage = false; // Reset showMessage flag when character starts moving
            drawCharacter();
            break;
          case 'ArrowUp':
            updateDirection("up");
            characterY -= characterSpeed;
            updateFrame();
            isMoving = true;
            showMessage = false; // Reset showMessage flag when character starts moving
            drawCharacter();
            break;
          case 'ArrowDown':
            updateDirection("down");
            characterY += characterSpeed;
            updateFrame();
            isMoving = true;
            showMessage = false; // Reset showMessage flag when character starts moving
            drawCharacter();
            break;
        }
    });

    // Reset the movement flag when the character stops moving
    document.addEventListener('keyup', function(event) {
        event.preventDefault();
        switch(event.key) {
          case 'ArrowLeft':
          case 'ArrowRight':
          case 'ArrowUp':
          case 'ArrowDown':
            isMoving = false;
            setSpeechBubbleTimeout()
        }
    });

    // Load character sprite sheet when it's loaded
    characterImage.onload = function() {
      drawCharacter();
    };

    // start initial speech bubble timeout func.
    setSpeechBubbleTimeout();

    function setSpeechBubbleTimeout () {
      setTimeout(function() {
          showMessage = true; // Set showMessage flag to true after a delay
          drawCharacter(); // Redraw the character to show the message
      }, messageDelay);
    };

  };

  </script>

</body>
</html>
